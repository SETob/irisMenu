{"version":3,"sources":["../src/helpers.ts","../src/put.ts"],"names":[],"mappings":";AAMO,SAAS,yBAAyB,SAAsC;AAC7E,MAAI,mCAAS,OAAO;AAClB,WAAO,QAAQ;AAAA,EACjB;AAEA,MAAI,QAAQ,IAAI,uBAAuB;AACrC,WAAO,QAAQ,IAAI;AAAA,EACrB;AAEA,QAAM,IAAI;AAAA,IACR;AAAA,EACF;AACF;AAEO,IAAM,YAAN,cAAwB,MAAM;AAAA,EACnC,YAAY,SAAiB;AAC3B,UAAM,gBAAgB,SAAS;AAAA,EACjC;AACF;AAEO,IAAM,kBAAN,cAA8B,MAAM;AAAA,EACzC,cAAc;AACZ;AAAA,MACE;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAM,mBAAN,cAA+B,MAAM;AAAA,EAC1C,cAAc;AACZ,UAAM,kEAAkE;AAAA,EAC1E;AACF;AAKA,IAAM,mBAAmB;AAElB,SAAS,sBAAoD;AAClE,MAAI,kBAAkB;AACtB,MAAI;AAGF,sBACE,QAAQ,IAAI,oCACZ,QAAQ,IAAI;AAAA,EAChB,QAAE;AAAA,EAEF;AAEA,SAAO;AAAA,IACL,iBAAiB,GAAG,4CAAmB;AAAA,EACzC;AACF;AAEO,SAAS,UAAU,WAAW,IAAY;AAC/C,MAAI,UAAU;AACd,MAAI;AAGF,cACE,QAAQ,IAAI,uBACZ,QAAQ,IAAI;AAAA,EAChB,QAAE;AAAA,EAEF;AACA,SAAO,GAAG,WAAW,oCAAoC;AAC3D;;;ACxEA,SAAS,aAAa;AAoCf,SAAS,gBAEd;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAIG;AACD,SAAO,eAAe,IACpB,UACA,MAQA,SACwB;AACxB,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,UAAU,sBAAsB;AAAA,IAC5C;AAEA,QAAI,CAAC,MAAM;AACT,YAAM,IAAI,UAAU,kBAAkB;AAAA,IACxC;AAEA,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,UAAU,4BAA4B;AAAA,IAClD;AAGA,QAAI,QAAQ,WAAW,UAAU;AAC/B,YAAM,IAAI,UAAU,yBAAyB;AAAA,IAC/C;AAEA,QAAI,aAAa;AACf,kBAAY,OAAO;AAAA,IACrB;AAEA,UAAM,QAAQ,WACV,MAAM,SAAS,UAAU,OAAO,IAChC,yBAAyB,OAAO;AAEpC,UAAM,UAAkC;AAAA,MACtC,GAAG,oBAAoB;AAAA,MACvB,eAAe,UAAU;AAAA,IAC3B;AAEA,QAAI,eAAe,SAAS,aAAa,KAAK,QAAQ,aAAa;AACjE,cAAQ,gBAAgB,IAAI,QAAQ;AAAA,IACtC;AAEA,QACE,eAAe,SAAS,iBAAiB,KACzC,QAAQ,oBAAoB,QAC5B;AACA,cAAQ,qBAAqB,IAAI,QAAQ,kBAAkB,MAAM;AAAA,IACnE;AAEA,QACE,eAAe,SAAS,oBAAoB,KAC5C,QAAQ,uBAAuB,QAC/B;AACA,cAAQ,yBAAyB,IAC/B,QAAQ,mBAAmB,SAAS;AAAA,IACxC;AAEA,UAAM,kBAAkB,MAAM,MAAM,UAAU,IAAI,UAAU,GAAG;AAAA,MAC7D,QAAQ;AAAA,MACR;AAAA,MACA;AAAA;AAAA;AAAA,MAGA,QAAQ;AAAA,IACV,CAAC;AAED,QAAI,gBAAgB,WAAW,KAAK;AAClC,UAAI,gBAAgB,WAAW,KAAK;AAClC,cAAM,IAAI,gBAAgB;AAAA,MAC5B,OAAO;AACL,cAAM,IAAI,iBAAiB;AAAA,MAC7B;AAAA,IACF;AAEA,UAAM,aAAc,MAAM,gBAAgB,KAAK;AAE/C,WAAO;AAAA,EACT;AACF","sourcesContent":["// common util interface for blob raw commands, not meant to be used directly\n// this is why it's not exported from index/client\nexport interface BlobCommandOptions {\n  token?: string;\n}\n\nexport function getTokenFromOptionsOrEnv(options?: BlobCommandOptions): string {\n  if (options?.token) {\n    return options.token;\n  }\n\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n\n  throw new BlobError(\n    'No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.'\n  );\n}\n\nexport class BlobError extends Error {\n  constructor(message: string) {\n    super(`Vercel Blob: ${message}`);\n  }\n}\n\nexport class BlobAccessError extends Error {\n  constructor() {\n    super(\n      'Vercel Blob: Access denied, please provide a valid token for this resource'\n    );\n  }\n}\n\nexport class BlobUnknownError extends Error {\n  constructor() {\n    super('Vercel Blob: Unknown error, please visit https://vercel.com/help');\n  }\n}\n\n// This version is used to ensure that the client and server are compatible\n// The server (Vercel Blob API) uses this information to change its behavior like the\n// response format\nconst BLOB_API_VERSION = 4;\n\nexport function getApiVersionHeader(): { 'x-api-version'?: string } {\n  let versionOverride = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to the BLOB_API_VERSION\n    versionOverride =\n      process.env.VERCEL_BLOB_API_VERSION_OVERRIDE ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n    // noop\n  }\n\n  return {\n    'x-api-version': `${versionOverride ?? BLOB_API_VERSION}`,\n  };\n}\n\nexport function getApiUrl(pathname = ''): string {\n  let baseUrl = null;\n  try {\n    // wrapping this code in a try/catch as this function is used in the browser and Vite doesn't define the process.env.\n    // As this varaible is NOT used in production, it will always default to production endpoint\n    baseUrl =\n      process.env.VERCEL_BLOB_API_URL ||\n      process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n    // noop\n  }\n  return `${baseUrl || 'https://blob.vercel-storage.com'}${pathname}`;\n}\n","import type { Readable } from 'node:stream';\nimport type { BodyInit } from 'undici';\nimport { fetch } from 'undici';\nimport type { ClientPutCommandOptions } from './client';\nimport type { BlobCommandOptions } from './helpers';\nimport {\n  BlobAccessError,\n  BlobUnknownError,\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  BlobError,\n} from './helpers';\n\nexport interface PutCommandOptions extends BlobCommandOptions {\n  access: 'public';\n  contentType?: string;\n  addRandomSuffix?: boolean;\n  cacheControlMaxAge?: number;\n}\n\nconst putOptionHeaderMap = {\n  cacheControlMaxAge: 'x-cache-control-max-age',\n  addRandomSuffix: 'x-add-random-suffix',\n  contentType: 'x-content-type',\n};\n\nexport interface PutBlobResult {\n  url: string;\n  pathname: string;\n  contentType: string;\n  contentDisposition: string;\n}\n\nexport type PutBlobApiResponse = PutBlobResult;\n\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport function createPutMethod<\n  T extends PartialBy<PutCommandOptions & ClientPutCommandOptions, 'token'>\n>({\n  allowedOptions,\n  getToken,\n  extraChecks,\n}: {\n  allowedOptions: (keyof typeof putOptionHeaderMap)[];\n  getToken?: (pathname: string, options: T) => Promise<string>;\n  extraChecks?: (options: T) => void;\n}) {\n  return async function put(\n    pathname: string,\n    body:\n      | string\n      | Readable\n      | Blob\n      | ArrayBuffer\n      | FormData\n      | ReadableStream\n      | File,\n    options?: T\n  ): Promise<PutBlobResult> {\n    if (!pathname) {\n      throw new BlobError('pathname is required');\n    }\n\n    if (!body) {\n      throw new BlobError('body is required');\n    }\n\n    if (!options) {\n      throw new BlobError('missing options, see usage');\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n    if (options.access !== 'public') {\n      throw new BlobError('access must be \"public\"');\n    }\n\n    if (extraChecks) {\n      extraChecks(options);\n    }\n\n    const token = getToken\n      ? await getToken(pathname, options)\n      : getTokenFromOptionsOrEnv(options);\n\n    const headers: Record<string, string> = {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${token}`,\n    };\n\n    if (allowedOptions.includes('contentType') && options.contentType) {\n      headers['x-content-type'] = options.contentType;\n    }\n\n    if (\n      allowedOptions.includes('addRandomSuffix') &&\n      options.addRandomSuffix !== undefined\n    ) {\n      headers['x-add-random-suffix'] = options.addRandomSuffix ? '1' : '0';\n    }\n\n    if (\n      allowedOptions.includes('cacheControlMaxAge') &&\n      options.cacheControlMaxAge !== undefined\n    ) {\n      headers['x-cache-control-max-age'] =\n        options.cacheControlMaxAge.toString();\n    }\n\n    const blobApiResponse = await fetch(getApiUrl(`/${pathname}`), {\n      method: 'PUT',\n      body: body as BodyInit,\n      headers,\n      // required in order to stream some body types to Cloudflare\n      // currently only supported in Node.js, we may have to feature detect this\n      duplex: 'half',\n    });\n\n    if (blobApiResponse.status !== 200) {\n      if (blobApiResponse.status === 403) {\n        throw new BlobAccessError();\n      } else {\n        throw new BlobUnknownError();\n      }\n    }\n\n    const blobResult = (await blobApiResponse.json()) as PutBlobApiResponse;\n\n    return blobResult;\n  };\n}\n"]}