// src/helpers.ts
function getTokenFromOptionsOrEnv(options) {
  if (options == null ? void 0 : options.token) {
    return options.token;
  }
  if (process.env.BLOB_READ_WRITE_TOKEN) {
    return process.env.BLOB_READ_WRITE_TOKEN;
  }
  throw new BlobError(
    "No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls."
  );
}
var BlobError = class extends Error {
  constructor(message) {
    super(`Vercel Blob: ${message}`);
  }
};
var BlobAccessError = class extends Error {
  constructor() {
    super(
      "Vercel Blob: Access denied, please provide a valid token for this resource"
    );
  }
};
var BlobUnknownError = class extends Error {
  constructor() {
    super("Vercel Blob: Unknown error, please visit https://vercel.com/help");
  }
};
var BLOB_API_VERSION = 4;
function getApiVersionHeader() {
  let versionOverride = null;
  try {
    versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;
  } catch {
  }
  return {
    "x-api-version": `${versionOverride != null ? versionOverride : BLOB_API_VERSION}`
  };
}
function getApiUrl(pathname = "") {
  let baseUrl = null;
  try {
    baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;
  } catch {
  }
  return `${baseUrl || "https://blob.vercel-storage.com"}${pathname}`;
}

// src/put.ts
import { fetch } from "undici";
function createPutMethod({
  allowedOptions,
  getToken,
  extraChecks
}) {
  return async function put(pathname, body, options) {
    if (!pathname) {
      throw new BlobError("pathname is required");
    }
    if (!body) {
      throw new BlobError("body is required");
    }
    if (!options) {
      throw new BlobError("missing options, see usage");
    }
    if (options.access !== "public") {
      throw new BlobError('access must be "public"');
    }
    if (extraChecks) {
      extraChecks(options);
    }
    const token = getToken ? await getToken(pathname, options) : getTokenFromOptionsOrEnv(options);
    const headers = {
      ...getApiVersionHeader(),
      authorization: `Bearer ${token}`
    };
    if (allowedOptions.includes("contentType") && options.contentType) {
      headers["x-content-type"] = options.contentType;
    }
    if (allowedOptions.includes("addRandomSuffix") && options.addRandomSuffix !== void 0) {
      headers["x-add-random-suffix"] = options.addRandomSuffix ? "1" : "0";
    }
    if (allowedOptions.includes("cacheControlMaxAge") && options.cacheControlMaxAge !== void 0) {
      headers["x-cache-control-max-age"] = options.cacheControlMaxAge.toString();
    }
    const blobApiResponse = await fetch(getApiUrl(`/${pathname}`), {
      method: "PUT",
      body,
      headers,
      // required in order to stream some body types to Cloudflare
      // currently only supported in Node.js, we may have to feature detect this
      duplex: "half"
    });
    if (blobApiResponse.status !== 200) {
      if (blobApiResponse.status === 403) {
        throw new BlobAccessError();
      } else {
        throw new BlobUnknownError();
      }
    }
    const blobResult = await blobApiResponse.json();
    return blobResult;
  };
}

export {
  getTokenFromOptionsOrEnv,
  BlobError,
  BlobAccessError,
  BlobUnknownError,
  getApiVersionHeader,
  getApiUrl,
  createPutMethod
};
//# sourceMappingURL=chunk-US63CWQW.js.map